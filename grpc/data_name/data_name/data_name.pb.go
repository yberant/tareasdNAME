// Code generated by protoc-gen-go. DO NOT EDIT.
// source: data_name.proto

package data_name

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type OrderResCode int32

const (
	OrderResCode_No  OrderResCode = 0
	OrderResCode_Yes OrderResCode = 1
)

var OrderResCode_name = map[int32]string{
	0: "No",
	1: "Yes",
}

var OrderResCode_value = map[string]int32{
	"No":  0,
	"Yes": 1,
}

func (x OrderResCode) String() string {
	return proto.EnumName(OrderResCode_name, int32(x))
}

func (OrderResCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b079518b506229e3, []int{0}
}

type OrderReq struct {
	// Types that are valid to be assigned to Req:
	//	*OrderReq_FileName
	//	*OrderReq_OrderData
	Req                  isOrderReq_Req `protobuf_oneof:"Req"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *OrderReq) Reset()         { *m = OrderReq{} }
func (m *OrderReq) String() string { return proto.CompactTextString(m) }
func (*OrderReq) ProtoMessage()    {}
func (*OrderReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_b079518b506229e3, []int{0}
}

func (m *OrderReq) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderReq.Unmarshal(m, b)
}
func (m *OrderReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderReq.Marshal(b, m, deterministic)
}
func (m *OrderReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderReq.Merge(m, src)
}
func (m *OrderReq) XXX_Size() int {
	return xxx_messageInfo_OrderReq.Size(m)
}
func (m *OrderReq) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderReq.DiscardUnknown(m)
}

var xxx_messageInfo_OrderReq proto.InternalMessageInfo

type isOrderReq_Req interface {
	isOrderReq_Req()
}

type OrderReq_FileName struct {
	FileName string `protobuf:"bytes,1,opt,name=FileName,proto3,oneof"`
}

type OrderReq_OrderData struct {
	OrderData *OrderData `protobuf:"bytes,2,opt,name=OrderData,proto3,oneof"`
}

func (*OrderReq_FileName) isOrderReq_Req() {}

func (*OrderReq_OrderData) isOrderReq_Req() {}

func (m *OrderReq) GetReq() isOrderReq_Req {
	if m != nil {
		return m.Req
	}
	return nil
}

func (m *OrderReq) GetFileName() string {
	if x, ok := m.GetReq().(*OrderReq_FileName); ok {
		return x.FileName
	}
	return ""
}

func (m *OrderReq) GetOrderData() *OrderData {
	if x, ok := m.GetReq().(*OrderReq_OrderData); ok {
		return x.OrderData
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderReq) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderReq_FileName)(nil),
		(*OrderReq_OrderData)(nil),
	}
}

type OrderData struct {
	ChunkId              int64    `protobuf:"varint,1,opt,name=ChunkId,proto3" json:"ChunkId,omitempty"`
	NodeId               int64    `protobuf:"varint,2,opt,name=NodeId,proto3" json:"NodeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderData) Reset()         { *m = OrderData{} }
func (m *OrderData) String() string { return proto.CompactTextString(m) }
func (*OrderData) ProtoMessage()    {}
func (*OrderData) Descriptor() ([]byte, []int) {
	return fileDescriptor_b079518b506229e3, []int{1}
}

func (m *OrderData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderData.Unmarshal(m, b)
}
func (m *OrderData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderData.Marshal(b, m, deterministic)
}
func (m *OrderData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderData.Merge(m, src)
}
func (m *OrderData) XXX_Size() int {
	return xxx_messageInfo_OrderData.Size(m)
}
func (m *OrderData) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderData.DiscardUnknown(m)
}

var xxx_messageInfo_OrderData proto.InternalMessageInfo

func (m *OrderData) GetChunkId() int64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *OrderData) GetNodeId() int64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

type OrderInfo struct {
	NodeId               int64    `protobuf:"varint,1,opt,name=NodeId,proto3" json:"NodeId,omitempty"`
	ChunkId              int64    `protobuf:"varint,2,opt,name=ChunkId,proto3" json:"ChunkId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OrderInfo) Reset()         { *m = OrderInfo{} }
func (m *OrderInfo) String() string { return proto.CompactTextString(m) }
func (*OrderInfo) ProtoMessage()    {}
func (*OrderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b079518b506229e3, []int{2}
}

func (m *OrderInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderInfo.Unmarshal(m, b)
}
func (m *OrderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderInfo.Marshal(b, m, deterministic)
}
func (m *OrderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderInfo.Merge(m, src)
}
func (m *OrderInfo) XXX_Size() int {
	return xxx_messageInfo_OrderInfo.Size(m)
}
func (m *OrderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OrderInfo proto.InternalMessageInfo

func (m *OrderInfo) GetNodeId() int64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *OrderInfo) GetChunkId() int64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

type OrderRes struct {
	ResCode              OrderResCode `protobuf:"varint,1,opt,name=ResCode,proto3,enum=data_name.OrderResCode" json:"ResCode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *OrderRes) Reset()         { *m = OrderRes{} }
func (m *OrderRes) String() string { return proto.CompactTextString(m) }
func (*OrderRes) ProtoMessage()    {}
func (*OrderRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_b079518b506229e3, []int{3}
}

func (m *OrderRes) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OrderRes.Unmarshal(m, b)
}
func (m *OrderRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OrderRes.Marshal(b, m, deterministic)
}
func (m *OrderRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderRes.Merge(m, src)
}
func (m *OrderRes) XXX_Size() int {
	return xxx_messageInfo_OrderRes.Size(m)
}
func (m *OrderRes) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderRes.DiscardUnknown(m)
}

var xxx_messageInfo_OrderRes proto.InternalMessageInfo

func (m *OrderRes) GetResCode() OrderResCode {
	if m != nil {
		return m.ResCode
	}
	return OrderResCode_No
}

func init() {
	proto.RegisterEnum("data_name.OrderResCode", OrderResCode_name, OrderResCode_value)
	proto.RegisterType((*OrderReq)(nil), "data_name.OrderReq")
	proto.RegisterType((*OrderData)(nil), "data_name.OrderData")
	proto.RegisterType((*OrderInfo)(nil), "data_name.OrderInfo")
	proto.RegisterType((*OrderRes)(nil), "data_name.OrderRes")
}

func init() { proto.RegisterFile("data_name.proto", fileDescriptor_b079518b506229e3) }

var fileDescriptor_b079518b506229e3 = []byte{
	// 267 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x91, 0x4b, 0x4b, 0xc3, 0x40,
	0x10, 0xc7, 0xb3, 0x09, 0xe6, 0x31, 0x2d, 0x5a, 0x46, 0xd1, 0x20, 0x82, 0x25, 0xa7, 0xe0, 0xa1,
	0x60, 0xf4, 0xa6, 0xbd, 0x58, 0x91, 0xe6, 0x12, 0x61, 0x6f, 0x9e, 0x64, 0x65, 0x47, 0x14, 0x4d,
	0xd6, 0x64, 0xd3, 0x8f, 0xe0, 0xf7, 0x96, 0xae, 0xed, 0x76, 0x7d, 0x9c, 0x7a, 0x9c, 0xf9, 0x3f,
	0x86, 0xdf, 0x2e, 0xec, 0x49, 0xd1, 0x8b, 0xc7, 0x46, 0xd4, 0x34, 0xf9, 0xe8, 0x54, 0xaf, 0x30,
	0xb1, 0x8b, 0x8c, 0x20, 0xbe, 0xef, 0x24, 0x75, 0x9c, 0x5a, 0x3c, 0x81, 0xf8, 0xee, 0xf5, 0x9d,
	0x2a, 0x51, 0x53, 0xca, 0xc6, 0x2c, 0x4f, 0xe6, 0x1e, 0xb7, 0x1b, 0xbc, 0x84, 0xc4, 0x38, 0x6f,
	0x45, 0x2f, 0x52, 0x7f, 0xcc, 0xf2, 0x41, 0x71, 0x30, 0xd9, 0x34, 0x5b, 0x6d, 0xee, 0xf1, 0x8d,
	0xf1, 0x66, 0x07, 0x02, 0x4e, 0x6d, 0x36, 0x75, 0xc2, 0x98, 0x42, 0x34, 0x7b, 0x59, 0x34, 0x6f,
	0xa5, 0x34, 0x67, 0x02, 0xbe, 0x1e, 0xf1, 0x10, 0xc2, 0x4a, 0x49, 0x2a, 0xa5, 0x39, 0x10, 0xf0,
	0xd5, 0x64, 0xe3, 0x65, 0xf3, 0xac, 0x1c, 0x13, 0x73, 0x4d, 0x6e, 0xad, 0xff, 0xa3, 0x36, 0x9b,
	0x5a, 0x48, 0x8d, 0xe7, 0x10, 0x71, 0xd2, 0x33, 0x25, 0xbf, 0x19, 0x77, 0x8b, 0xa3, 0xdf, 0x10,
	0x2b, 0x99, 0xaf, 0x7d, 0x67, 0xa7, 0x30, 0x74, 0x05, 0x0c, 0xc1, 0xaf, 0xd4, 0xc8, 0xc3, 0x08,
	0x82, 0x07, 0xd2, 0x23, 0x56, 0x7c, 0x32, 0x88, 0x97, 0x64, 0xe6, 0x9d, 0xae, 0x61, 0xc8, 0xa9,
	0x5d, 0x90, 0xee, 0x4d, 0x08, 0xf7, 0xff, 0xf6, 0xb7, 0xc7, 0xff, 0x2c, 0x75, 0xe6, 0xe5, 0x0c,
	0xaf, 0x60, 0xb0, 0x84, 0xec, 0xea, 0x2d, 0xc2, 0x4f, 0xa1, 0xf9, 0xde, 0x8b, 0xaf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x4a, 0xc2, 0xa5, 0xe2, 0xf1, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DataNameClient is the client API for DataName service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DataNameClient interface {
	//NO IMPLEMENTADO AÚN
	//este se usa solo en caso de que el algoritmo sea de exclusion centralizada:
	RequestOrder(ctx context.Context, opts ...grpc.CallOption) (DataName_RequestOrderClient, error)
	//NO IMPLEMENTADO AÚN
	//datanode informa al namenode cual es el orden que tiene que escribir en el log
	InformOrder(ctx context.Context, opts ...grpc.CallOption) (DataName_InformOrderClient, error)
}

type dataNameClient struct {
	cc *grpc.ClientConn
}

func NewDataNameClient(cc *grpc.ClientConn) DataNameClient {
	return &dataNameClient{cc}
}

func (c *dataNameClient) RequestOrder(ctx context.Context, opts ...grpc.CallOption) (DataName_RequestOrderClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataName_serviceDesc.Streams[0], "/data_name.DataName/RequestOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNameRequestOrderClient{stream}
	return x, nil
}

type DataName_RequestOrderClient interface {
	Send(*OrderReq) error
	CloseAndRecv() (*OrderRes, error)
	grpc.ClientStream
}

type dataNameRequestOrderClient struct {
	grpc.ClientStream
}

func (x *dataNameRequestOrderClient) Send(m *OrderReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNameRequestOrderClient) CloseAndRecv() (*OrderRes, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OrderRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *dataNameClient) InformOrder(ctx context.Context, opts ...grpc.CallOption) (DataName_InformOrderClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DataName_serviceDesc.Streams[1], "/data_name.DataName/InformOrder", opts...)
	if err != nil {
		return nil, err
	}
	x := &dataNameInformOrderClient{stream}
	return x, nil
}

type DataName_InformOrderClient interface {
	Send(*OrderReq) error
	CloseAndRecv() (*OrderRes, error)
	grpc.ClientStream
}

type dataNameInformOrderClient struct {
	grpc.ClientStream
}

func (x *dataNameInformOrderClient) Send(m *OrderReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dataNameInformOrderClient) CloseAndRecv() (*OrderRes, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(OrderRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DataNameServer is the server API for DataName service.
type DataNameServer interface {
	//NO IMPLEMENTADO AÚN
	//este se usa solo en caso de que el algoritmo sea de exclusion centralizada:
	RequestOrder(DataName_RequestOrderServer) error
	//NO IMPLEMENTADO AÚN
	//datanode informa al namenode cual es el orden que tiene que escribir en el log
	InformOrder(DataName_InformOrderServer) error
}

// UnimplementedDataNameServer can be embedded to have forward compatible implementations.
type UnimplementedDataNameServer struct {
}

func (*UnimplementedDataNameServer) RequestOrder(srv DataName_RequestOrderServer) error {
	return status.Errorf(codes.Unimplemented, "method RequestOrder not implemented")
}
func (*UnimplementedDataNameServer) InformOrder(srv DataName_InformOrderServer) error {
	return status.Errorf(codes.Unimplemented, "method InformOrder not implemented")
}

func RegisterDataNameServer(s *grpc.Server, srv DataNameServer) {
	s.RegisterService(&_DataName_serviceDesc, srv)
}

func _DataName_RequestOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNameServer).RequestOrder(&dataNameRequestOrderServer{stream})
}

type DataName_RequestOrderServer interface {
	SendAndClose(*OrderRes) error
	Recv() (*OrderReq, error)
	grpc.ServerStream
}

type dataNameRequestOrderServer struct {
	grpc.ServerStream
}

func (x *dataNameRequestOrderServer) SendAndClose(m *OrderRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNameRequestOrderServer) Recv() (*OrderReq, error) {
	m := new(OrderReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DataName_InformOrder_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DataNameServer).InformOrder(&dataNameInformOrderServer{stream})
}

type DataName_InformOrderServer interface {
	SendAndClose(*OrderRes) error
	Recv() (*OrderReq, error)
	grpc.ServerStream
}

type dataNameInformOrderServer struct {
	grpc.ServerStream
}

func (x *dataNameInformOrderServer) SendAndClose(m *OrderRes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dataNameInformOrderServer) Recv() (*OrderReq, error) {
	m := new(OrderReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _DataName_serviceDesc = grpc.ServiceDesc{
	ServiceName: "data_name.DataName",
	HandlerType: (*DataNameServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RequestOrder",
			Handler:       _DataName_RequestOrder_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "InformOrder",
			Handler:       _DataName_InformOrder_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "data_name.proto",
}
